#summary 4.1 API.

<wiki:toc />

= Introduction =

Les variables et les fonctions que vous trouverez ici peuvent aussi bien être définies dans les bibliothèques écrites en Lua (tag _libs_) ou dans le code C (tag _nds_).

= Notes du traducteur =

== Clavier ==

Il n’est plus fait mention du clavier, celui-ci ayant été enlevé des bibliothèques de base de MicroLua. Vous pouvez toujours trouver une version traduite et opérationnelle sur le forum.

== Types de variables ==

Les types de variables n'ont pas été traduits pour des raisons de compréhension générale. En programmation, on parlera plus facilement de « string » que de « chaîne de caractères ». Voici les correspondances françaises des types employés ici:

  * `Void`: « vide » (utilisé par une fonction qui ne renvoie rien)
  * `Number`: nombre
  * `String`: chaîne de caractères
  * `Color`: couleur
  * `Image`: image
  * `Font`: police d'écriture
  * `Table`: table (ou tableau)
  * `Map` & `ScrollMap`: carte et carte défilante
  * `Canvas` & `CanvasObject`: canevas & objet de canevas
  * `Constant`: constante
  * `Boolean`: booléen (`true` – vrai, ou `false` – faux)
  * `DateTime`: objet représentant une date
  * `Handle`: référence d’un objet pour le gérer

= API =

== Variables ==

  * *`ULUA_VERSION`* (_nds_) : version de Micro Lua (sous forme d’un String)
  * *`SCREEN_WIDTH`*, *`SCREEN_HEIGHT`* (_nds_) : largeur et hauteur des écrans
  * *`NB_FPS`* (_libs_) : nombre de _frames_ (images) par seconde, automatiquement mis à jour chaque seconde.
  * *`SCREEN_UP`*, *`SCREEN_DOWN`* (_nds_) : numéro de l’écran sur lequel afficher les éléments. Voir les exemples pour de plus amples détails.
  * *`RAM`*, *`VRAM`* (_nds_) : destination du chargement de certains objets. Voir les exemples pour de plus amples détails.
  * *`ATTR_X1`*, *`ATTR_Y1`*, *`ATTR_X2`*, *`ATTR_Y1`*, *`ATTR_X3`*, *`ATTR_Y3`*, *`ATTR_COLOR`*, *`ATTR_COLOR1`*, *`ATTR_COLOR2`*, *`ATTR_COLOR3`*, *`ATTR_COLOR4`*, *`ATTR_TEXT`*, *`ATTR_VISIBLE`*, *`ATTR_FONT`*, *`ATTR_IMAGE`* (_nds_) : attributs utilisés par les canevas.
  * *`ALPHA_RESET`* (_nds_ ) : valeur du coefficient de transparence pour réinitialiser l''alpha transparency'. Par defaut elle vaut 100.
  * *`PLAY_LOOP`*, *`PLAY_ONCE`* (_nds_) : arguments pour jouer des 'mods' respectivement 'loop' et 'once'.
  * Constantes de chemins (certaines sont formées à partir des précédentes) (_nds_):
   * *`ULUA_DIR`*: _/lua/_ (dossier principal de MicroLua)
   * *`ULUA_SCRIPTS`*: _ULUA_DIR scripts/_ (dossier par défaut pour les scripts)
   * *`ULUA_LIBS`*: _ULUA_DIR libs/_ (dossier par défaut pour les librairies)
   * *`ULUA_BOOT_FILE`*: _boot.lua_ (premier fichier chargé par MicroLua)
   * *`ULUA_BOOT_FULLPATH`*: _ULUA_DIR ULUA_BOOTFILE_ (chemin complet du premier fichier chargé par MicroLua)
  * *`mustCountFPS`* (_libs_) : régule le système de comptabilisation des FPS. C'est une variable interne, vous ne devriez jamais en avoir besoin.
  * *`Debug.isDebugOn`*, *`Debug.debugText`* et *`Debug.debugColor`* (_libs_): variables utilisées par le système de debuging. Vous devez les modifier uniquement en utilisant les fonctions `Debug` .
  
== Les fonctions et leur tableau ==

=== L’écran ===

*`Void render()`* (_libs_)

Actualise l’écran.

*`Void startDrawing()`* & *`Void stopDrawing()`* (_libs_, _deprecated_)

Toutes vos opérations graphiques doivent être placées entre ces deux fonctions.

*`Void screen.switch()`* (_nds_)

Intervertit l’affichage des écrans.

*`Number screen.getLayer()`* (_nds_)

Obtient le groupe de transparence actuel.

*`Number screen.getAlphaLevel()`* (_nds_)

Obtient le niveau de transparence actuel.

*`Void screen.setAlpha(niveau[, groupe])`* (_nds_)

Définit le niveau de transparence du groupe donné.
  * *niveau* (Number) : niveau de transparence, de 0 à 99 (100, ou ALPHA_RESET, remet tout le système de transparence à zéro)
  * *groupe* (Number) : groupe de transparence ; la fonction tient automatiquement le compte

*`Void screen.print(ecran, x, y, texte [, couleur])`* (_nds_)

Affiche un texte à l’écran.
  * *ecran* (Number) : écran sur lequel dessiner (`SCREEN_UP` ou `SCREEN_DOWN`)
  * *x* (Number) : abscisse du coin haut-gauche du texte
  * *y* (Number) : ordonnée du coin haut-gauche du texte
  * *texte* (String) : texte à afficher
  * *couleur* (Color) : couleur du texte

*`Void screen.printFont(ecran, x, y, texte, couleur, police)`* (_nds_)

Affiche un texte à l’écran dans une police spéciale.
  * *ecran* (Number) : écran sur lequel dessiner (`SCREEN_UP` ou `SCREEN_DOWN`)
  * *x* (Number) : abscisse du coin haut-gauche du texte
  * *y* (Number) : ordonnée du coin haut-gauche du texte
  * *texte* (String) : texte à afficher
  * *couleur* (Color) : couleur du texte
  * *police* (Font) : police spéciale

*`Void screen.blit(ecran, x, y, image [,sourceX, sourceY] [, largeur, hauteur])`* (_nds_)

_Blitte_ (affiche) une image à l’écran.
  * *ecran* (Number) : écran sur lequel afficher l'image (`SCREEN_UP` ou `SCREEN_DOWN`)
  * *x* (Number) : abscisse du coin haut-gauche de l’image
  * *y* (Number) : ordonnée du coin haut-gauche de l’image
  * *image* (Image) : image à blitter
  * *sourceX*, *sourceY* (Number) : coordonnées de la partie de l’image source à blitter
  * *largeur*, *hauteur* (Number): dimensions de la partie de l’image source à blitter

*`Void screen.drawPoint(ecran, x, y, couleur)`* (_nds_)

Dessine un point à l'écran.
  * *ecran* (Number) : écran sur le quel dessiner (`SCREEN_UP` ou `SCREEN_DOWN`)
  * *x*, *y* (Number) : coordonnées du point
  * *couleur* (Color) : couleur du point

*`Void screen.drawLine(ecran, x0, y0, x1, y1, couleur)`* (_nds_)

Dessine une ligne à l’écran.
  * *ecran* (Number) : écran sur lequel dessiner (`SCREEN_UP` ou `SCREEN_DOWN`)
  * *x0*, *y0*, *x1*, *y1* (Number) : coordonnées de la ligne
  * *couleur* (Color) : couleur de la ligne

*`Void screen.drawRect(ecran, x0, y0, x1, y1, couleur)`* (_nds_)

Dessine un rectangle à l’écran.
  * *ecran* (Number) : écran sur lequel dessiner (`SCREEN_UP` ou `SCREEN_DOWN`)
  * *x0*, *y0*, *x1*, *y1* (Number) : coordonnées du rectangle
  * *couleur* (Color) : couleur du rectangle

*`Void screen.drawFillRect(ecran, x0, y0, x1, y1, couleur)`* (_nds_)

Dessine un rectangle plein à l’écran.
  * *ecran* (Number) : écran sur lequel dessiner (`SCREEN_UP` ou `SCREEN_DOWN`)
  * *x0*, *y0*, *x1*, *y1* (Number) : coordonnées du rectangle plein
  * *couleur* (Color) : couleur du rectangle plein

*`Void screen.drawGradientRect(ecran,  *x0*, *y0*, *x1*, *y1*, couleur1, couleur2, couleur3, couleur4)`* (_nds_)

Dessine un rectangle dégradé à l’écran.
  * *ecran* (Number) : écran sur lequel dessiner (`SCREEN_UP` ou `SCREEN_DOWN`)
  * *x0*, *y0*, *x1*, *y1* (Number) : coordonnées du rectangle dégradé
  * *couleur1*, *couleur2*, *couleur3*, *couleur4* (Color) : couleurs du rectangle dégradé

*`Void screen.drawTextBox(ecran, x0, y0, x1, y1, texte [, couleur])`* (_nds_)

Affiche une zone de texte à l’écran.
  * *ecran* (Number) : écran sur lequel dessiner (`SCREEN_UP` ou `SCREEN_DOWN`)
  * *x0*, *y0*, *x1*, *y1* (Number) : coordonnées de la zone de texte
  * *texte* (String) : texte à afficher
  * *couleur* (Color) : couleur de la zone de texte

*`Void screen.drawTexturedQuad(ecran, x0, y0, x1, y1, x2, y2, x3, y3, texture[, sourceX, sourceY][, largeur, hauteur])`* (_nds_)

Affiche un quadrilatère texturé.
  * *ecran* (Number) : écran sur lequel dessiner (`SCREEN_UP` ou `SCREEN_DOWN`)
  * *x0*, *y0*, *x1*, *y1*... (Number) : coordonnées des angles du quadrilatère
  * *texture* (Image) : image de la texture
  * *sourceX*, *sourceY* (Number) : coordonnées de la partie de l’image à utiliser comme texture
  * *largeur*, *hauteur* (Number): dimensions de la partie de l’image à utiliser comme texture

*`Void screen.drawTexturedTriangle(ecran, x0, y0, x1, y1, x2, y2, texture[, sourceX, sourceY][, largeur, hauteur])`* (_nds_)

Affiche un triangle texturé.
  * *ecran* (Number) : écran sur lequel dessiner (`SCREEN_UP` ou `SCREEN_DOWN`)
  * *x0*, *y0*, *x1*, *y1*... (Number) : coordonnées des angles du triangle
  * *texture* (Image) : image de la texture
  * *sourceX*, *sourceY* (Number) : coordonnées de la partie de l’image à utiliser comme texture
  * *largeur*, *hauteur* (Number) : dimensions de l'image à utiliser comme texture
  
*`Boolean screen.getMainLcd()`* (_nds_)

Retourne l'écran sur lequel µLua dessine (`true` pour l'écran du haut, `false` pour l'écran du bas).

*`Void screen.setSpaceBetweenScreens(space)`* (_nds_, _deprecated_ (vous ne pouvez plus dessinez sur les deux écran en même temps.))

Définit l'espace entre les deux écrans (certain dessin ne seront pas affiché si ils sont dessinés dans cet espace.).
  * *space* (Number): espace (en pixels) entre les écrans.

*`Void screen.init()`* (_nds_)

Initialise tout ce qui touche aux écrans. Cela est fait automatiquement, donc vous ne devez pas vous en occupez.

*`Void screen.startDrawing2D()`* (_nds_)

Démarre un nouvel affichage en 2D. Vous ne devez pas vous en occupez.

*`Void screen.endDrawing()`* (_nds_)

Termine le cycle d'affichage. Vous ne devez jamais l'utilisez (utilisez `render()` pour commander une actualisation d'affichage).

*`Void screen.waitForVBL()`* (_nds_)

Attend une periode VBlank pour atteindre 60FPS. Vous ne devez jamais l'utilisez (utilisez `render()` pour synchroniser les frames).

=== Couleurs ===

*`Color Color.new(r, v, b)`* (_nds_)

Crée une nouvelle couleur.
  * *r* (Number): masque rouge (de 0 à 31 inclus)
  * *v* (Number): masque vert (de 0 à 31 inclus)
  * *b* (Number): masque bleu (de 0 à 31 inclus)

=== Contrôles ===

*`Void Controls.read()`* (_libs_)

Met à jour les commandes.

==== Stylet ====

Ce sont des nombres ou des booléens, tous définis dans les _libs_.

*`Stylus.X`*: abscisse du stylet

*`Stylus.Y`*: ordonnée du stylet

*`Stylus.held`*: état appuyé sur l'écran du stylet

*`Stylus.released`*: état relâché du stylet

*`Stylus.doubleClick`*: vaut `true` si le stylet effectue un double-clic

*`Stylus.deltaX`*: delta X (accroissement de X) du mouvement du stylet

*`Stylus.deltaY`*: delta Y (accroissement de Y) du mouvement du stylet

*`Stylus.newPress`*: vaut `true` si le stylet effectue une nouvelle pression

==== Boutons ====

Voici des booléens. Toute cette section est définie dans les _libs_.

(`[KEY]` peut prendre une des valeurs suivantes:
*`A`, `B`, `X`, `Y`, `L`, `R`, `Start`, `Select`, `Up`, `Down`, `Left`, `Right`*)

*`Keys.held.[KEY]`*: état enfoncé du bouton

*`Keys.released.[KEY]`*: état relâché du bouton

*`Keys.newPress.[KEY]`*: vaut `true` si le bouton effectue une nouvelle pression

=== Images ===

*`Image Image.load(chemin, destination)`* (_nds_)

Crée une nouvelle image depuis un fichier image (PNG, JPG – JPEG ou GIF).
  * *chemin* (String): chemin d'accès du fichier image à charger
  * *destination* (Number): destination de l'image dans la mémoire (`RAM` ou `VRAM`)


*`Void Image.destroy(image)`* (_nds_)

Détruit une image.
  * *image* (Image): image à détruire

Pour détruire complètement l'image, faire
{{{
Image.destroy(monImage)
monImage = nil
}}}

*`Number Image.width(image)`* (_nds_)

Obtient la longueur d'une image.
  * *image* (Image): image à utiliser
                                                     
*`Number Image.height(image)`* (_nds_)

Obtient la largeur d'une image.
  * *image* (Image): image à utiliser

*`Void Image.scale(image, longueur, largeur)`* (_nds_)

Agrandit (ou réduit) l'image.
  * *image* (Image): image à modifier
  * *longueur* (Number): nouvelle longueur de l'image
  * *largeur* (Number): nouvelle largeur de l'image

*`Void Image.rotate(image, angle [, xCentre, yCentre])`* (_nds_)

Fait pivoter l'image autour du centre de rotation indiqué.
  * *image* (Image): image à modifier
  * *angle* (Number): angle de rotation (entre 0 et 511)
  * *xCentre* (Number): abscisse du centre de rotation
  * *yCentre* (Number): ordonnée du centre de rotation

*`Void Image.rotateDegree(image, angle [, xCentre, yCentre])`* (_nds_)

Fait pivoter l’image autour du centre de rotation indiqué.  L’angle est en degrés.
  * *image* (Image) : image à modifier
  * *angle* (Number) : angle de rotation, en degrés (entre 0 et 360)
  * *xCentre* (Number) : abscisse du centre de rotation
  * *yCentre* (Number) : ordonnée du centre de rotation

*`Void Image.mirrorH(image)`* (_nds_)

Réalise une symétrie horizontale de l'image.
  * *image* (Image): image à modifier

*`Void Image.mirrorV(image)`* (_nds_)

Réalise une symétrie verticale de l'image.
  * *image* (Image): image à modifier

*`Void Image.setTint(image, couleur)`* (_nds_)

Définit la teinte de l'image.
  * *image* (Image): image à modifier
  * *couleur* (Color): couleur de l'image

=== Timers (chronomètres) ===

L'unité est la milliseconde.

*`Timer Timer.new()`* (_libs_)

Crée un nouveau timer ; vous pouvez le démarrer.

*`Number timer:time()`* (_libs_)

Renvoie le temps d'un timer.

*`Void Timer:start()`* (_libs_)

Démarre un timer.

*`Void Timer:stop()`* (_libs_)

Arrête un timer.

*`Void timer:reset()`* (_libs_)

Réinitialise un timer.

=== Sprites ===

<wiki:comment>(succession d'images – les frames – pour créer une animation)</wiki:comment>

*`Sprite Sprite.new(chemin, longueurFrame, largeurFrame, destination)`* (_libs_)

Crée un sprite depuis un fichier image.
  * *chemin* (String): chemin d'accès du fichier qui contient le sprite
  * *longueurImage* (Number): longueur d'une frame
  * *largeurImage* (Number): largeur d'une frame
  * *destination* (Number): destination en mémoire (`RAM` ou `VRAM`)


*`Void sprite:drawFrame(ecran, x, y, numFrame)`* (_libs_)

Affiche une frame du sprite.
  * *ecran* (Nombre) : écran sur lequel afficher (`SCREEN_UP` ou `SCREEN_DOWN`)
  * *x* (Nombre) : abscisse du coin haut-gauche de la frame
  * *y* (Nombre) : ordonnée du coin haut-gauche de la frame
  * *numFrame* (Number): numéro de la frame à afficher

*`Void sprite:addAnimation(tabAnim, delais)`* (_libs_)

Crée une animation.
  * *tabAnim* (Table): table des frames de l'animation
  * *delais* (Number): délais entre chaque frame

*`Void sprite:playAnimation(ecran, x, y, numAnim)`* (_libs_)

Joue une animation à l'écran.
  * *ecran* (Number): écran sur lequel afficher (`SCREEN_UP` ou `SCREEN_DOWN`)
  * *x* (Number): abscisse du coin haut-gauche de l'animation
  * *y* (Number): ordonnée du coin haut-gauche de l'animation
  * *numAnim* (Number): numéro de l'animation à jouer

*`Void sprite:resetAnimation(numAnim)`* (_libs_)

Réinitialise une animation.
  * *numAnim* (Number): numéro de l'animation à réinitialiser.

*`Void sprite:startAnimation(numAnim)`* (_libs_)

Démarre une animation.
  * *numAnim* (Number): numéro de l'animation à démarrer

*`Void sprite:stopAnimation(numAnimation)`* (_libs_)

Arrête une animation.
  * *numAnim* (Number) : numéro de l'animation à arrêter

*`Boolean sprite:isAnimationAtEnd(numAnim)`* (_libs_)

Renvoie `true` si l'animation a affiché la dernière frame.
  * *numAnim* (Number): numéro de l'animation

*`Table SpriteAnimation.new(tabAnim, delay)`* (_nds_)

Crée une nouvelle animation de Sprite. Vous ne devez pas l'utiliser, utilisez `sprite:addAnimation()` .
  * *tabAnim* (Table): table contenant les frames de l'animations.
  * *delay* (Number): delais entre chaque frames.

=== Déboguage ===

*`Void Debug.ON()`* (_libs_)

Active le mode de déboguage.

*`Void Debug.OFF()`* (_libs_)

Désactive le mode déboguage.

*`Void Debug.print(texte)`* (_libs_)

Affiche une ligne de déboguage.
  * *texte* (String): texte à afficher

*`Void Debug.clear()`* (_libs_)

Efface la console de déboguage.

*`Void Debug.setColor(couleur)`* (_libs_)

Définit la couleur du texte de déboguage.
  * *couleur* (Color): couleur du texte

=== Système ===

*`String System.currentDirectory()`* (_nds_)

Obtient le répertoire actuel.

*`Void System.changeDirectory(chemin)`* (_nds_)

Change le répertoire actuel.
  * *chemin* (String): chemin du dossier

*`Void System.remove(nom)`* (_nds_)

Supprime un fichier ou un répertoire vide.
  * *nom* (String): nom du fichier ou du dossier à supprimer

*`Void System.rename(ancienNom, nouveauNom)`* (_nds_)

Renomme un fichier ou un répertoire vide.
  * *ancienNom* (String): nom du fichier ou du dossier à renommer
  * *nouveauNom* (String): nouveau nom du fichier ou du dossier

*`Void System.makeDirectory(nom)`* (_nds_)

Crée un nouveau répertoire.
  * *nom* (String): chemin d'accès et nom du dossier

*`Table System.listDirectory(chemin)`* (_nds_)

Liste tous les fichiers et répertoires d'un dossier.
  * *chemin* (String): chemin d'accès du dossier à lister

*NOTE*: Voir les exemples pour plus de détails.

*`Number System.CurrentVramUsed()`* (_nds_)

Retourne le total de VRAM utilisée (semble retourner un chiffre bizarre).

*`Number System.CurrentVramFree()`* (_nds_)

Retourne le total de VRAM libre.

*`Number System.CurrentPalUsed()`* (_nds_)

Retourne le total de 'mémoire palette' utilisée (semble retourner un chiffre bizarre).

*`Number System.CurrentPalFree()`* (_nds_)

Retourne le total de 'mémoire palette' libre.


=== Polices ===

*`Font Font.load(chemin)`* (_nds_)

Crée une nouvelle police depuis un fichier de police (au format oslib et µLibrairy).
  * *chemin* (String): chemin d'accès du fichier police à charger

*`Number Font.getCharHeight(police)`* (_nds_)

Obtient la hauteur des caractères d'une police.
  * *police* (Font): police à utiliser

*`Number Font.getStringWidth(police, texte)`* (_nds_)

Obtient la largeur d’un texte avec une police spéciale.
  * *police* (Font) : police à utiliser
  * *texte* (String) : texte

*`Void Font.destroy(police)`* (_nds_)

Libère la mémoire en supprimant la police.
  * *police* (Font) : police à supprimer de la mémoire.

=== Cartes ===

*`Map Map.new(image, fichierCarte, longueur, largeur, longueurTuile, largeurTuile)`* (_nds_)

Crée une nouvelle carte à partir d'un fichier carte.
  * *image* (Image): image qui contient les tuiles
  * *fichierCarte* (String): chemin d'accès au fichier carte (`.map`)
  * *longueur* (Number): longueur de la carte en tuile
  * *largeur* (Number): largeur de la carte en tuile
  * *longueurTuile* (Number): longueur d'une tuile en pixel
  * *largeurTuile* (Number): largeur d'une tuile en pixel

*`Void Map.destroy(carte)`* (_nds_)

Détruit une carte.
  * *carte* (Map): carte à détruire

*`Void Map.draw(ecran, carte, x, y, longueur, largeur)`* (_nds_)

Affiche une carte.
  * *ecran* (Number): écran sur lequel afficher la carte (peut être `SCREEN_UP` ou `SCREEN_DOWN`)
  * *carte* (Map): carte à afficher
  * *x* (Number): abscisse du coin haut-gauche de la carte
  * *y* (Number): ordonnée du coin haut-gauche de la carte
  * *longueur* (Number): nombre de tuiles à afficher sur la longueur
  * *largeur* (Number): nombre de tuiles à afficher sur la largeur

*`Void Map.scroll(carte, x, y)`* (_nds_)

Fait défiler une carte.
  * *carte* (Map): carte à faire défiler
  * *x* (Number): nombre de tuiles à faire défiler sur la longueur
  * *y* (Number): nombre de tuiles à faire défiler sur la largeur

*`Void Map.space(carte, x, y)`* (_nds_)

Définit l'espace entre chaque tuile de la carte.
  * *carte* (Map): carte à modifier
  * *x* (Number): espace sur la longueur entre chaque tuile
  * *y* (Number): espace sur la largeur entre chaque tuile

*`Void Map.setTile(carte, x, y, tuile)`* (_nds_)

Change la valeur d'une tuile.
  * *carte* (Map): carte à modifier
  * *x* (Number): numéro de la colonne de la tuile à changer dans la carte
  * *y* (Number): numéro de la ligne de la tuile à changer dans la carte
  * *tuile* (Number): nouvelle valeur de tuile

*`Number Map.getTile(carte, x ,y)`* (_nds_)

Obtient une valeur de tuile.
  * *carte* (Map): carte qui contient la tuile voulue
  * *x* (Number): numéro de la colonne de la tuile à obtenir
  * *y* (Number): numéro de la ligne de la tuile à obtenir

=== Cartes défilantes ===

*`ScrollMap ScrollMap.new(image, fichierCarte, longueur, largeur, longueurTuile, largeurTuile)`* (_nds_)

Crée une nouvelle carte défilante.
  * *image* (Image): image qui contient les tuiles
  * *fichierCarte* (String): chemin d'accès du fichier carte (.map)
  * *longueur* (Number): longueur de la carte en tuile
  * *largeur* (Number): largeur de la carte en tuile
  * *longueurTuile* (Number): longueur d'une tuile en pixel
  * *largeurTuile* (Number): largeur d'une tuile en pixel

*`Void ScrollMap.destroy(carteDefilante)`* (_nds_)

Détruit une carte défilante.
  * *carteDéfilante* (ScrollMap): carte défilante à détruire

*`Void ScrollMap.draw(carteDefilante)`* (_nds_)

Affiche une carte défilante.
  * *carteDéfilante* (ScrollMap): carte défilante à afficher

*`Void ScrollMap.scroll(carteDefilante, x, y)`* (_nds_)

Fait défiler une carte défilante.
  * *carteDefilante* (ScrollMap): carte défilante à faire défiler
  * *x* (Number): abscisse du coin haut-gauche de la map (peut être négative)
  * *y* (Number): ordonnée du coin haut-gauche de la map (peut être négative)

*`Void ScrollMap.setTile(carteDefilante, x, y, tuile)`* (_nds_)

Change la valeur d'une tuile.
  * *carteDefilante* (ScrollMap): carte défilante à modifier
  * *x* (Number): numéro de la colonne de la tuile à changer dans la carte
  * *y* (Number): numéro de la ligne de la tuile à changer dans la carte
  * *tuile* (Number): nouvelle valeur de tuile

*`Number ScrollMap.getTile(carteDefilante, x ,y)`* (_nds_)

Obtient une valeur de tuile.
  * *carteDefilante* (ScrollMap): carte défilante qui contient la tuile voulue
  * *x* (Number): numéro de la colonne de la tuile à obtenir
  * *y* (Number): numéro de la ligne de la tuile à obtenir

=== Canevas ===

*`Canvas Canvas.new()`* (_nds_)

Crée un nouveau canevas.

*`Void Canvas.destroy(canevas)`* (_nds_)

Détruit un canevas. Doit être suivi de canevas = nil.
  * *canevas* (Canvas): canevas à détruire

*`CanvasObject Canvas.newLine(x1, y1, x2, y2, couleur)`* (_nds_)

Crée une nouvelle ligne.
  * *x1*, *y1*, *x2*, *y2* (Number): coordonnées de la ligne
  * *couleur* (Color): couleur de la ligne

*`CanvasObject Canvas.newPoint(x1, y1, couleur)`* (_nds_)

Crée un nouveau point.
  * *x1*, *y1* (Number): coordonnées du point
  * *couleur* (Color): couleur du point

*`CanvasObject Canvas.newRect(x1, y1, x2, y2, couleur)`* (_nds_)

Crée un nouveau rectangle.
  * *x1*, *y1*, *x2*, *y2* (Number): coordonnées du rectangle
  * *couleur* (Color): couleur du rectangle

*`CanvasObject Canvas.newFillRect(x1, y1, x2, y2, couleur)`* (_nds_)

Crée un nouveau rectangle plein.
  * *x1*, *y1*, *x2*, *y2* (Number): coordonnées du rectangle
  * *couleur* (Color): couleur du rectangle

*`CanvasObject Canvas.newGradientRect(x1, y1, x2, y2, couleur1, couleur2, couleur3, couleur4)`* (_nds_)

Crée un nouveau rectangle dégradé.
  * *x1*, *y1*, *x2*, *y2* (Number): coordonnées du rectangle
  * *couleur1*, *couleur2*, *couleur3*, *couleur4* (Color): couleurs du rectangle

*`CanvasObject Canvas.newText(x, y, texte [, couleur])`* (_nds_)

Crée un nouveau texte.
  * *x* (Nombre) : abscisse du coin haut-gauche du texte
  * *y* (Nombre) : ordonnée du coin haut-gauche du texte
  * *texte* (String): texte
  * *couleur* (Color): couleur du texte

*`CanvasObject Canvas.newTextFont(x, y, texte, couleur, police)`* (_nds_)

Crée un nouveau texte avec une police spéciale.
  * *x* (Nombre) : abscisse du coin haut-gauche du texte
  * *y* (Nombre) : ordonnée du coin haut-gauche du texte
  * *texte* (String): texte
  * *couleur* (Color): couleur du texte
  * *police* (Font): police spéciale du texte

*`CanvasObject Canvas.newTextBox(x1, y1, x2 , y2, texte [, couleur])`* (_nds_)

Crée une nouvelle zone de texte.
  * *x1*, *y1*, x1, y2 (Number): coordonnées de la zone de texte
  * *texte* (String): texte de la zone de texte
  * *couleur* (Color): couleur de la zone de texte

*`CanvasObject Canvas.newImage(x1, y1, image [, x2, y2][, x3, y3])`* (_nds_)

Crée une nouvelle image.
  * *x1*, *y1* (Number): coordonnées du coin haut-gauche de l’image
  * *image* (Image): image
  * *x2*, *y2* (Number): coordonnées du coin haut-gauche du rectangle à prendre dans l'image source
  * *x3*, *y3* (Number): longueur et largeur du rectangle à prendre dans l’image source

*`Void Canvas.add(canevas, objet)`* (_nds_)

Ajoute un CanvasObject dans un canevas.
  * *canevas* (Canvas): canevas à modifier
  * *objet* (CanvasObject): objet à ajouter

*`Void Canvas.draw(ecran, canevas, x, y,)`* (_nds_)

Affiche un canevas à l'écran.
  * *ecran* (Number): écran sur lequel dessiner (`SCREEN_UP` ou `SCREEN_DOWN`)
  * *canevas* (Canvas): canevas à afficher
  * *x* (Number): abscisse du coin haut-gauche de l'image
  * *y* (Number): ordonnée du coin haut-gauche de l'image

*`Void Canvas.setAttr(objet, nomAttr, valeurAttr)`* (_nds_)

Définit la valeur d'un attribut d'un CanvasObject.
  * *objet* (CanvasObject): objet à modifier
  * *nomAttr* (Constant): attribut à modifier. Doit être soir la forme ATTR_XXX. Voir « Quelques variables utiles » pour de plus amples informations.
  * *valeurAttr* (?): nouvelle valeur de l'attribut. Le type doit être le même que celui de l'attribut.

*`? Canvas.getAttr(objet, nomAttr)`* (_nds_)

Obtient la valeur d'un attribut. Le type de retour dépend de l'attribut demandé.
  * *objet* (CanvasObject): objet à utiliser
  * *nomAttr* (Constant | Nombre): attribut dont la valeur est demandée. Doit être sous la forme ATTR_XXX. Voir « Quelques variables utiles » pour de plus amples informations
  
*`Void Canvas.setObjOnTop(canvas, object)`* (_nds_)

Fait passer un objet d'un canevas au premier plan.
  * *canvas* (Canvas) : Canevas dans lequel on travail.
  * *object* (CanvasObject) : Objet que l'on désire faire passer au premier plan.
  
*`Void Canvas.removeObj(canvas, object)`* (_nds_)

Suppression d'un objet dans un canevas.
  * *canvas* (Canvas) : Canevas dans lequel on veut supprimer l'objet.
  * *object* (CanvasObject) : Objet que l'on désire supprimer.

=== Rumble ===

*`Boolean Rumble.isInserted()`* (_nds_)

Vérifie qu’un pack rumble (vibration) soit inséré.

*`Void Rumble.set(statut)`* (_nds_)

Définit le statut du rumble.
  * *statut* (Boolean) : statut du rumble (`true` : marche ; `false` : arrêt)

=== Motion (détection de mouvement) ===

*`Boolean Motion.init()`* (_nds_)

Initialise le système Motion si un périphérique Motion est détecté. Renvoie `true` si un périphérique Motion est détecté.

*`Void Motion.calibrate()`* (_nds_)

Effectue le calibrage du système Motion.

*`Number Motion.readX()`* (_nds_)

Renvoie l’inclinaison X du système Motion.

*`Number Motion.readY()`* (_nds_)

Renvoie l’inclinaison Y du système Motion.

*`Number Motion.readZ()`* (_nds_)

Renvoie l’inclinaison Z du système Motion.

*`Number Motion.accelerationX()`* (_nds_)

Retourne l’accélération X du système Motion.

*`Number Motion.accelerationY()`* (_nds_)

Retourne l’accélération Y du système Motion.

*`Number Motion.accelerationZ()`* (_nds_)

Retourne l’accélération Z du système Motion.

*`Number Motion.readGyro()`* (_nds_)

Retourne la valeur de gyro du système Motion.

*`Number Motion.rotation()`* (_nds_)

Retourne la valeur de rotation du système Motion.

=== Date et heure ===

*`DateTime DateTime.new()`* (_libs_)

Crée un nouvel objet DateTime.

*`DateTime DateTime.getCurrentTime()`* (_libs_)

Crée un nouvel objet DateTime avec l’heure et la date courantes.

*Attributs* (Numbers) :
  * *`year`* : an
  * *`month`* : mois
  * *`day`* : jour
  * *`hour`* : heure
  * *`minute`* : minute
  * *`second`* : seconde

*NOTE*: Voir les exemples pour plus de détails.

=== Wifi ===

*`Void Wifi.connectWFC()`* (_nds_)

Connecte la DS à la connexion Wifi. Utilise la configuration du firmware. Par conséquent, vous devez configurer votre connexion avec un jeu DS officiel.

*`Void Wifi.initDefault()`* (_nds_)

Initialise le wifi de la DS. Doit être fait avant toute autre fonction Wifi. Ne pas utiliser avec la fonction Wifi.connectWFC().

*`Void Wifi.autoConnectWFC()`* (_nds_)

Identique à la fonction Wifi.connectWFC() mais s'éxécute après un Wifi.initDefault().

*`Void Wifi.scanAP()`* (_nds_)

Passe le wifi de la DS en mode detection d'Access Point (Point d'acces tel que Livebox, Freebox, Neufbox...). Une fois lancé, la DS recherche tout le temps mais n'empéche pas de faire autre chôse comme une connection ou autre.

*`Number Wifi.getNumAP()`* (_nds_)

Retourne le nombre d'AP trouvée suite à un Wifi.scanAP(). La recherche peut être longue.

*`Tableau Wifi.newAP()`* (_nds_)

Retourne un tableau vide regroupant le squelette des données d'un Point d'Acces (AP, pour `Access Point`).

*Attributs* :
  * *`ssid`* (String) : nom du réseau fourni par l'AP
  * *`bssid`* (String) :
  * *`macaddr`* (String) : adresse Mac de l'AP.
  * *`channel`* (Number) : numéro de canal du réseau.
  * *`rssi`* (Number) : force du signal.
  * *`maxrate`* (Number) : vitesse maximum de communication (1M ou 2M)
  * *`protection`* (String) : indique la protection du Wifi (NONE, WEP, WPA)
  * *`adhoc`* (Boolean) : indique si la connection est de type adhoc (`true`) ou non (`false`)
  * *`active`* (Boolean) : indique si la connection est active (`true`) ou non (`false`)

*`Tableau Wifi.getAP(numap)`* (_nds_) 

Retourne le tableau regroupant les données de l'AP de numéro `numap` trouvé par la fonction `Wifi.scanAP()`.
  * *numap* (Number) : numéro de l'AP désiré.

*`Number Wifi.connectAP(numap, numkey, key)`* (_nds_)

Lance une demande d'association à l'AP de numéro `numap` en utilisant le numéro de clef  `numkey` et la clef `key`.
Si l'association se fait à un point d'accès non protégé, mettre 1 en `numkey` et une chaine vide ("") en `key`.
`numkey` va de 1 à 4. C'est généralement la première clef qui est utilisée.
Retourne -1 si l'association est refusée.
  * *numap* (Number) : numéro de l'AP souhaité.
  * *numkey* (Number) : numéro de la clef utilisée.
  * *key* (String) : clef WEP.

*`Void Wifi.disconnect()`* (_nds_)

Déconnecte la DS de la connexion Wifi.

*`Void Wifi.stop()`* (_nds_)

Désengage le Wifi pour une économie de baterrie.

*`String Wifi.getLocalConf(choix)`* (_nds_)

Retourne les données souhaitées en fonction du choix.
  * *choix* (Number) : 
    * *1* Retourne l'adresse IP de la DS
    * *2* Retourne le GateWay de la DS
    * *3* Retourne le SubnetMask de la DS
    * *4* Retourne le DNS1 de la DS
    * *5* Retourne le DNS2 de la DS
    * *6* Retourne l'adresse Mac de la DS

*`Void Wifi.resetIP()`* (_nds_)

Réinitialise les données IP, GateWay, SubnetMask et DNS de la DS.
Si exécuté avant une association, la DS interroge le serveur DHCP pour récupérer ces données.

*`Void Wifi.setLocalIp(ip, gateway[, subnetmask[, dns1[, dns2]]])`* (_nds_)

Assigne l'adresse IP, le gateWay, le subnetMask et les DNS à la DS. Les chaine de caractères doivent être de la forme "N1.N2.N3.N4" où Nx est un entier allant de 0 à 255.
  * *ip* (String) : adresse IP demandé.
  * *gateway* (String) : adresse du gateWay.
  * *subnetmask* (String) : le SubnetMask.
  * *dns1* (String) : adresse du DNS principal.
  * *dns2* (String) : adresse de DNS secondaire.

*`Socket Wifi.createTCPSocket(hote, port)`* (_nds_)

Crée un socket TCP vers un serveur.
  * *hote* (String) : nom de domaine ou adresse IP du serveur
  * *port* (Number) : port à utiliser

*`Socket Wifi.createUDPSocket(hote, port)`* (_nds_)

Crée un socket UDP vers un serveur.
  * *hote* (String) : nom de domaine ou adresse IP du serveur
  * *port* (Number) : port à utiliser

*`Void Wifi.closeSocket(socket)`* (_nds_)

Ferme un socket (TCP comme UDP).
  * *socket* (Socket) : socket à fermer

*`Void Wifi.send(socket, donnees)`* (_nds_)

Envoie des données à un serveur en passant par un socket.
  * *socket* (Socket) : socket à utiliser
  * *donnees* (String) : données à envoyer
  
*`Number Wifi.checkData(socket)`* (_nds_)

Vérifie si des données sont en attente dans le buffer du Wifi et retourne le nombre de caractères contenuent dans celui-ci.
  * *socket* (Socket) : socket à vérifié.

*`String Wifi.receive(socket, longueur)`* (_nds_)

Reçoit des données depuis un serveur en passant par un socket.
  * *socket* (Socket) : socket à utiliser
  * *longueur* (Number) : taille des données à recevoir

=== Sons ===

==== Banques de son ====

*`Void Sound.loadBank(nomFichier)`* (_nds_)

Charge une banque de son depuis un fichier en mémoire.
  * *nomFichier* (String) : chemin du fichier à charger

*`Void Sound.unloadBank()`* (_nds_)

Décharge la banque de son de la mémoire.

==== Mods ====

*`Void Sound.loadMod(index)`* (_nds_)

Charge un module en mémoire.
  * *index* (Number) : index du module à charger

*`Void Sound.unloadMod(index)`* (_nds_)

Décharge un module de la mémoire.
  * *index* (Number) : index du module à décharger

*`Void Sound.startMod(index, modeLecture)`* (_nds_)

Lance la lecture d’un module déjà chargé en mémoire.
  * *index* (Number) : index du module à jouer
  * *modeLecture* (Number) : mode de lecture (peut être `PLAY_ONCE` – jouer une fois – ou `PLAY_LOOP` – jouer en boucle)

*`Void Sound.pause()`* (_nds_)

Met en pause tous les modules.

*`Void Sound.resume()`* (_nds_)

Relance la lecture de tous les modules.

*`Void Sound.stop()`* (_nds_)

Arrête la lecture de tous les modules.

*`Void Sound.setPosition(index, position)`* (_nds_)

Définit la position du curseur de lecture dans un module.
  * *index* (Number) : index du module
  * *position* (Number) : nouvelle position du curseur

*`Boolean Sound.isActive()`* (_nds_)

Retourne `true` si le lecteur est actif, sinon retourne `false`.

*`Void Sound.startJingle(index)`* (_nds_)

Lance la lecture d’un module comme un jingle.
  * *index* (Number) : index du volume à jouer

*`Void Sound.setModVolume(volume)`* (_nds_)

Définit le volume du module joué.
  * *volume* (Number) : nouvelle valeur du volume, comprise entre 0 et 1024

*`Void Sound.setJingleVolume(volume)`* (_nds_)

Définit le volume du jingle joué.
  * *volume* (Number) : nouvelle valeur du volume, comprise entre 0 et 1024

*`Void Sound.setModTempo(tempo)`* (_nds_)

Définit le tempo du lecteur de module.
  * *tempo* (Number) : nouvelle valeur du tempo, comprise entre 512 et 2048

*`Void Sound.setModPitch(ton)`* (_nds_)

Définit le ton du lecteur de module.
  * *ton* (Number) : nouvelle valeur du ton
  * *SFX* (effets sonores) :

*`Void Sound.loadSFX(index)`* (_nds_)

Charge un SFX dans la mémoire.
  * *index* (Number) : index du SFX à charger

*`Void Sound.unloadSFX(index)`* (_nds_)

Décharge un SFX de la mémoire.
  * *index* (Number) : index du SFX à décharger

*`Handle Sound.startSFX(index)`* (_nds_)

Démarre un effet sonore déjà chargé en mémoire. Retourne un handle de cet SFX.
  * *index* (Number) : index du SFX à lire

*`Void Sound.stopSFX(handle)`* (_nds_)

Arrête un SFX joué.
  * *handle* (Handle) : handle d’un SFX, retourné par la fonction startSFX

*`Void Sound.releaseSFX(handle)`* (_nds_)

Marque un effet en priorité faible.
  * *handle* (Handle) : handle d’un SFX, retourné par la fonction startSFX

*`Void Sound.stopAllSFX()`* (_nds_)

Arrête tous les SFX joués.

*`Void Sound.setSFXVolume(handle, volume)`* (_nds_)

Définit le volume d’un SFX joué.
  * *handle* (Handle) : handle d’un SFX, retourné par la fonction startSFX
  * *volume* (Number) : nouvelle valeur du volume, comprise entre 0 et 255 (différente de celle des mods)

*`Void Sound.setSFXPanning(handle, balance)`* (_nds_)

Définit la balance d’un SFX joué.
  * *handle* (Handle) : handle d’un SFX, retourné par la fonction startSFX
  * *balance* (Number) : nouvelle valeur de la balance, comprise entre 0 (gauche) et 255 (droite)

*`Void Sound.setSFXPitch(handle, ton)`* (_nds_)

Définit le ton d’un SFX joué.
  * *handle* (Handle) : handle d’un SFX, retourné par la fonction startSFX
  * *ton* : nouvelle valeur du ton

*`Void Sound.setSFXScalePitch(handle, gamme)`* (_nds_)

Définit la gamme de ton d’un SFX joué.
  * *handle* (Handle) : handle d’un SFX, retourné par la fonction startSFX
  * *gamme* (Number) : nouvelle valeur de gamme du ton

=== Fichiers INI ===

*`Table INI.load(nomFichier)`* (_libs_)

Charge un fichier INI et crée une table avec son contenu.
  * *nomFichier* (String): fichier à charger

*`Void INI.save(nomFichier, table)`* (_libs_)

Sauvegarde une table dans un fichier INI.
  * *nomFichier* (String): fichier dans lequel la table sera sauvegardée
  * *table* (Table): table à sauvegarder

*Exemple :*

Un fichier INI contient:
{{{
[infos]
nom=toto
age=25
}}}
{{{
tab = INI.load('monFichier.ini')
table['infos']['nom'] = 'tata'
INI.save('monFichier.ini', tab)
}}}
Cet exemple change la ligne `nom=toto` en `nom=tata`.

Les tables de données des fichiers INI ne peuvent contenir que des Strings !
Si vous voulez sauvegarder des nombres, vous devez d'abord les convertir en String grâce à `tostring()`.

=== Informations Utilisateurs ===

==== Functions ====

Ces fonctions ne sont pas vraiment utiles mais les variables ci-dessous les utilisent.

*`Number dsUser.getColor()`* (_nds_)

Retourne la couleur du théme choisie, entre 0 et 15.

*`Number dsUser.getBirthDay()`* (_nds_)

Retourne le jour de naissance.

*`Number dsUser.getBirthMonth()`* (_nds_)

Retourne le mois de naissance.

*`String dsUser.getName()`* (_nds_)

Retourne le pseudo.

*`Number dsUser.getNameLength()`* (_nds_)

Retourne la taille du pseudo.

*`String dsUser.getMessage()`* (_nds_)

Retourne le message personnel.

*`Number dsUser.getMessageLength()`* (_nds_)

Retourne la taille du message personnel.

*`Number dsUser.getAlarmHour()`* (_nds_)

Retourne l'heure de l'alarme.

*`Number dsUser.getAlarmMinute()`* (_nds_)

Retourne les minutes de l'alarme.

*`Number dsUser.getLanguage()`* (_nds_)

Retourne le language choisi, entre 0 et 5.

*`Boolean dsUser.getGBAScreen()`* (_nds_)

Retourne l'écran choisi pour le mode GBA (`true` pour l'écran du haut, et `false` pour celui du bas).

*`Number dsUser.getDefaultBrightness()`* (_nds_)

Retourne la luminositée par defaut (entre 0 et 3 à partir de la DSLite)

*`Boolean dsUser.getAutoMode()`* (_nds_)

Retourne la configuration de l'auto démarrage (`true si activé et `false` si désactivé).

==== Variables ====

Elles sont définies dans _nds_.

*`(Number) dsUser.color`*: donne la couleur du théme, entre 0 et 15.

*`(Number) dsUser.birthDay`*: donne le jour d'anniversaire.

*`(Number) dsUser.birthMonth`*: donne le mois d'anniversaire.

*`(String) dsUser.name`*: donne le pseudo.

*`(Number) dsUser.nameLength`*: donne la taille du pseudo.

*`(String) dsUser.message`*: donne le message personnel.

*`(Number) dsUser.messageLength`*: donne la taille du message personnel.

*`(Number) dsUser.alarmHour`*: donne l'heure de l'alarme.

*`(Number) dsUser.alarmMinute`*: donne les minutes de l'alarme.

*`(Number) dsUser.language`*: donne la langue de l'utilisateur, entre 0 et 5.

*`(Boolean) dsUser.GBAScreen`*: donne l'écran choisi pour le mode GBA (`true` pour l'écran du haut, `false` pour l'écran du bas).

*`(Number) dsUser.defaultBrightness`*: donne la luminausité par défaut (entre 0 et 3 pour une NDSl ou une NDSi).

*`(Boolean) dsUser.getAutoMode`*: donne l'état du démarrage automatique (`true` si activé, et `false` si désactivé).